#  Input System (sketch)
## Goals
* The input system should produce the key events pressed/released/held for each raw controller input (e.g. pressed the 'A' key, pressed the 'Square' button, etc).

## Issues
1. A potential issue with a simple polling system is that if the engine frame time is particularly large - as though we're playing OoT on the N64 - there may be circumstances in which a button is pressed and released between input polls, leading to circumstances in which the user feels the input was consumed by the engine, but no response occurs. This issue isn't exactly a problem for the childlike nursery engine that exists so far, but it makes for a nice little exercise in how to fix this problem.
2. A more prominent issue arises with the kind of philosophy with the engine. Namely, that (almost) all state should be immutable. If we want a system which says "this key was pressed (i.e. it was not active at the previous frame)", or "this key was released (i.e. it was active at the previous frame but not at this frame)", then the system needs some kind of memory to keep track of which keys were down in the last frame. Currently, the only memory we have is the `world` object. The two basic solutions to this issue are 1. adding a, say, `previousFrameInput` property in `world`, or 2. adding a `previousFrameInput:` parameter to the loop method. Ignoring performance, both solutions have, in some way, a problem of data from unrelated systems seeping into places where they shouldn't. The `world` object is currently an inelegant solution to the initial problem of removing mutable state from the engine, existing only to dump game state objects until a more elegant solution is found. Putting unrelated data from the input system, or a possible future animation system, into `world` is deferring the solution until later. Adding a `previousFrameInput:` parameter to the loop method only has the relative benefit over solution 1. of removing the cost of deferencing the `world` object, but does not solve the major issue at hand.

## Potential solutions
1. The simplest implementation of an input system is to poll for current inputs whenever the engine calls `askInput()`. This conflicts with issues 1. and 2.
2. A big brain solution is to have the input system run on its own loop with its own framerate which should be at least as fast as the maximum engine framerate. In this loop, there is an input buffer of some length related to the engine frame time containing input events. the system asks the computer for the raw input, then it uses this plus the buffer passed over from the previous input loop to compute events and, add them to the buffer, and return the buffer ready for the next pass of the loop. An example buffer could look like the following (with `p(x)` meaning "key `x` was pressed", `h(x)` meaning "key `x` was held", and `r(x)` meaning "key `x` was released"):
```
INPUT  | .    .    .    p(A) h(A) h(A) h(A) r(A) .    p(S) h(S) h(S) h(S) h(S) h(S) h(S) r(S) .
       | .    .    .    .    .    .    .    .    .    .    .    p(D) h(D) r(D) .    .    .    .
```
This now presents an issue which the author is nowhere near big-brained enough to solve. Namely, suppose the engine is now asking for the input. How does it get the buffer, and how is the buffer cleared? More importantly, what should a loop look like? The current engine loop was stitched together like a maniac whose only goal was just "uhh make a loop because recursion is causing a stack overflow", and contains contains the only significant `var` in the code. Making a nice architectural change in this area in order to facilitate an input loop should therefore be a priority. 
